# 五子棋竞技场思路



## 4/13

建表：

1.User table：存放用户数据，包括：id，昵称（唯一昵称），注册凭证：手机号码或者邮箱二选一，密码；

2.Gamer table：存放游戏数据信息，包括：Gamer_id，段位、战绩、胜率、游玩场次数、胜场数，是否位于房间中

3.HistoricGame table：存放历史对局信息：包括：对局id（对局开始时间（包括年月日时分秒组成）与顺序生产的3位数字组成，共17位），对局起止时间、对战信息（对手，对战结果）

4.RealTimeGame table：存放实时对局信息，包括：对局id（对局开始时间（包括年月日时分秒组成）与顺序生产的3位数字组成，共17位），棋子位置（要存放两个人的数据），对局开始时间，对局玩家信息，用户在线情况

5.Room table：存放房间数据，包括：房间号（月份加日期和4位随机数字），是否公开，房间密码（不公开则为空字符串），房主id，嘉宾id

6.chessstyle：将对局与最终棋盘样式关联，包括：id：对局id，finalchessstyle：最终棋盘样式的id，由对局结束时间（包括年月日时分秒）和对局id的最后四位组成，共17位

7.chessStyle：将对局与棋盘进行关联，包括：id(对局id)，finalchessstyle_id(27位)棋盘样式id（最终棋盘样式实际上时更新到胜负分晓后的棋盘样式）





User与Gamer通过id外键连接，

HistoricGame 与Gamer 通过Gamer_with_HistoricGame表关联,通过game_id与棋盘最终样式关联

RealTimeGame与HIstoricGame通过对局id进行关联，通过game_id与实时棋盘样式关联

Room通过Gamer_id与Gamer相关联





**为了解决棋盘数据庞大导致查询时间过长，采用动态创建棋盘表的方式：**

**棋盘：数据库名由对局id+chess_style(27位)组成**

​		**包括：chess_possion**

**棋子:包括：棋子id（判断第几步，自动更新），棋子坐标chess_possion（char（2）），八个方位的Boolean值（forward,rear,left,right,leftfront,leftrear,rightfront,rightrear）**





解决快速判断棋子是否连成一条线的方法：在棋子周围设置8个方位为boolean值，如果为true则记录对应方向并向对应方向进行延申，并设置一个计数器，如果计数器达到5则判为胜





## 4/14

前后端代码组成：

**前端：**

1.login界面：实现登录功能（和login界面可以互相跳转）

2.register界面：实现注册功能

3.gameMajor界面：实现主界面菜单功能（包括创建房间功能、加入房间功能、个人信息查看功能、段位首页显示、快速匹配功能）（gameMajor界面可以和房间界面进行交互，对战界面只能在确认进入游戏时选择是否进入，选择否则返回主界面，选择是则跳转到游戏界面且只有在游戏结束（认输或则败时才能回到主界面）

4.房间界面：包括房间号显示，房间密码设置和更改，

5.对战界面：包括显示棋盘，判断先后手，实时显示棋盘，判断胜负，显示下棋时间，倒计时功能，检测是否在线，实现认输功能

6.更改密码：

**后端（实现数据交互与判断）：**

1.用户功能：注册、登录、修改密码

2.玩家功能：段位展示与更新、战绩展示与更新

3.游戏功能：**判断是否胜利**：通过设置棋子的是否具有连线成功的潜力进行判断（0：棋子没有连线成功的潜力，即以4颗棋子为半径的范围内的每条线都存在白棋，先读取一个方位的遇到的第一颗白棋位置，再在相反方位读取（5-1+i）颗棋子判断是否有白棋，若没有，且存在空的格子，则将潜力设置为1（如果能够顺利填满该线则可以成功连线）若已经在一个方向上存在5颗棋子则设置为2，并判断胜利），对局数据保存，断线重连功能（重连时间应该比下棋时间短）



为了正确游玩五子棋，对规则进行查阅得知一些规则：**PASS权**‌：除前五手外，双方均可选择放弃行棋（PASS），但需由对方继续落子后才能恢复行棋权利;‌**长连无效**‌：若一方形成六子或以上的“长连”，黑棋判负（禁手），白棋无此限制。**三三禁手**‌：一子同时形成两个或以上的“活三”（即未阻挡的三连）;**四四禁手**‌：一子同时形成两个或以上的“四”（包括活四或冲四)；若禁手与五连同时形成，禁手失效，判黑方胜。‌**三手可交换**‌：黑方下完前三手后，白方可选择交换执黑或继续执白，‌**五手两打**‌：黑方第五手需在棋盘上放置两枚棋子（位置不对称），由白方选择保留一枚继续对弈，禁手后：**立即判负**：如果黑方落子后形成禁手，且被白方（或裁判）当场指出并确认，则黑方直接输掉比赛。**白方需主动指出**：禁手需由白方在落下一手前指出才有效（若白方未发现而继续落子，禁手可能不再追究）。**禁止落子**：黑方不能主动选择形成禁手的落点（若故意走禁手点，直接判负）。





经分析，项目实现应为以下：

![1744632346536](C:\Users\Pumpkin\AppData\Roaming\Typora\typora-user-images\1744632346536.png)

需要开辟一个主服务器对用户传递的数据进行传输，难点在于如何实现绑定用户a和用户b的连接通道，既然要和多个用户进行通信，就需要使用多线程管理用户，由于有快速匹配和创建房间两种模式，因此分开讨论：

快速匹配：快速匹配时匹配随机的同样处于匹配队列的玩家，因此需要一个匹配队列的容器，在容器中存放处于匹配状态下的用户的ip和端口号，在匹配过程中选择死循进行匹配直到用户点击取消匹配或者成功获取其他玩家的ip并进行绑定，绑定方式为使用容器进行绑定

房间模式：房主在创建房间时向服务器提交房间号后创建唯一的房间容器进行容纳用户ip和端口号，当收到其他用户的加房请求时将该用户的ip和端口号添加到容器中，实现绑定

依照此思想可以使用Map集合进行绑定，在key中放置随机匹配的某个用户~~的id~~或者房主~~id~~  的socket，在value中存放另一个用户的~~ip和端口号~~  socket。



## 4.15

使用token令牌进行用户数据的获取和验证，token包含三部分：header（可以明文的数据）+Payload（加密内容）+Signature（签名）

token传递的数据需要进行加密，加密流程为：获得salt和密钥->通过密钥和salt对数据进行加密，这里使用HmacSHA256进行加密->获得加密后的数据以后上传到response的Authorization头上，由客户端接收并存储，在后续发送请求时将通过请求发送给服务器，

获得Authorization头后验证的方式是取出payloader进行同样的加密操作获得签名并与携带的签名进行对比

## 4.16

个人信息界面采用弹框方式展示，在弹框中通过导航菜单进行展示

完成了前端页面的设置

## 4.17

完成个人信息界面后端的设置，排查了个人信息界面出现的问题

## 4.18

完成了个人信息修改的内容，解决了个人信息修改中出现的无法传递Authorization头的问题，解决了个人信息界面中父组件无法传递给子组件数据的问题，解决了后端密文解密的问题，修改了加密的方式

## 4.19

进入核心玩法的实现，主要通过网络编程的方式进行实现



公网ip：101.37.135.39

私网ip：172.23.153.56



测试能否实现数据传输



room功能实现思路：

创建房间功能：客户端提交room数据到后台后发送ip和roomId给服务器，服务器特定端口接收数据（id和密码和onwerid）后创建相应线程，并向客户端发送成功创建的数据，客户端接收到成功的数据后返回成功信息给前端，前端接收数据后跳转到房间页面，由于一个账号一次只能创建一个房间，因此不需要再客户端创建房间信息对应的表，只需要将房间信息作为令牌传入前端，再修改时只需要更改令牌中的内容并向服务器传入修改房间信息的数据，令牌此时的使用方法为：传入创建请求时将令牌的payload改造成：password+RoomId+roomPassword，key也进行对应的修改并生成新的签名，在退出房间后将令牌转换为只存放password的令牌，退出房间功能：前端接受到退出指令后向后台发送退出请求，后台接收到请求后向服务器发送异步的断开连接的请求，服务器接收到请求后清空对应的room数据，如果清空失败则服务器向客户端发送清空失败的信息，服务端接收到信息后再次将数据传入到服务器中并继续执行

加入房间功能：弹窗显示输入房间id页面，提交后发送到服务器，服务器对传入的房间id进行查找，如果在数据库中找到再向客户端发送找到的请求，服务端接收到找到的请求后向网页发送已经找到的信息和存放的密码数据，页面根据后端发送的信息和房间是否公开的信息弹出弹框，输入密码并进行校验，若正确则进入，若错误则跳转发送错误信息

由以上可以得出：客户端需要创建的方法有：创建房间，将创建房间数据传递给服务器，加入房间，将输入的id传给服务器

服务器需要的方法有：接收客户端传入的创建房间请求，接收客户端发送的加入房间请求，创建房间，通过id查找房间，查找所有房间，通过id和密码查找房间，修改房间数据



## 4.20

创建一个房间的步骤是客户端前台向后台发送请求，后台接受到请求后与服务器进行连接，服务器收到请求后向客户端发送收到收到请求的消息，客户端验证消息同时向服务器发送创建房间的请求，服务器收到创建房间的请求后进行记录，同时客户端向服务器输出房间的信息，服务器在收到信息后进行创建房间并返回创建房间的结果

创建房间使用websocket的方式进行数据传输，以此保证可以持续监听服务器是否发送加房请求



数据传输使用websocket直接传输



## 4.21

实现房间中的两个用户通过中继服务器建立连接：

​	使用websocket将客户端与服务器进行连接，实现高速传递用户信息和操作指令，socket建立连接的时机为用户在网页提交创建房间的请求，将将用户建立连接的唯一标识设置为用户的websocketURL，服务器的websocket设置为固定值，这样就可以解决在创建连接时未知客户端websocket的情况下成功连接

​	客户端websocket为”ws://。。。。/id=?/Room

​	向服务器发送的消息应该包含两部分，一部分为指令，一部分为Room的值，使用Base64进行转码，转换成16进制字符串，字符串前半部分为指令的值，后半部份为Room的值，Room的值为JSON字符串，两部分用"."分隔

​	优化与服务器的连接时机：转换为登录成功时客户端自动向服务器发送请求，服务器接收请求后将用户数据保存服务器端，需要保存的数据有：客户端的session，用户的id（作为查找索引使用，用于溯源查询用户端的数据）



加入房间出现数据交互频繁问题：房间数据仅包含房主id，创建房间还需要获取房主和房客的用户数据，会频繁调用数据接收与返回，解决方法：websocket在底层进行处理接收数据，因此无法循环等待成功接受数据，这里采用的解决方案是分批发送数据

加入房间的过程：房客向服务器发送加房请求-》服务器接受到加房请求后在服务器进行数据添加-》服务器添加数据成功后向房主和房客发送消息-》房主和房客接收到消息后向服务器发送用户数据-》房主和房客收到对方数据后渲染并加载进入房间界面



修改房间过程:房主向服务器发送修改房间请求和修改数据，服务器接受到数据后进行数据修改，如果修改成功，检查房间中是否存在房客并向房主（和房客（如果有））发送修改后的数据（房客不能接受房间密码）